<div class="container">

<table style="width: 100%;"><tr>
<td>zlib</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>zlib</h2>

<h3>Description</h3>

<p>What My Package Offers
</p>
<p>This package provides several key features:
</p>

<dl>
<dt><strong>Robustness:</strong></dt>
<dd>
<p>Built to handle even corrupted or incomplete gzip data efficiently without causing system failures.</p>
</dd>
<dt>Demonstration:</dt>
<dd>
<pre>
  compressed_data &lt;- memCompress(charToRaw(paste0(rep("This is an example string. It contains more than just 'hello, world!'", 1000), collapse = ", ")))
  decompressor &lt;- zlib$decompressobj(zlib$MAX_WBITS)
  rawToChar(c(decompressor$decompress(compressed_data[1:300]), decompressor$flush()))  # Still working
  </pre>
</dd>
<dt><strong>Compliance:</strong></dt>
<dd>
<p>Strict adherence to the GZIP File Format Specification, ensuring compatibility across systems.</p>
</dd>
<dt>Demonstration:</dt>
<dd>
<pre>
  compressor &lt;- zlib$compressobj(zlib$Z_DEFAULT_COMPRESSION, zlib$DEFLATED, zlib$MAX_WBITS + 16)
  c(compressor$compress(charToRaw("Hello World")), compressor$flush())  # Correct 31 wbits (or custom wbits you provide)
  # [1] 1f 8b 08 00 00 00 00 00 00 03 f3 48 cd c9 c9 57 08 cf 2f ca 49 01 00 56 b1 17 4a 0b 00 00 00
  </pre>
</dd>
<dt><strong>Flexibility:</strong></dt>
<dd>
<p>Ability to manage Gzip streams from REST APIs without the need for temporary files or other workarounds.</p>
</dd>
<dt>Demonstration:</dt>
<dd>
<pre>
    # Byte-Range Request and decompression in chunks

    # Initialize the decompressor
    decompressor &lt;- zlib$decompressobj(zlib$MAX_WBITS + 16)

    # Define the URL and initial byte ranges
    url &lt;- "https://example.com/api/data.gz"
    range_start &lt;- 0
    range_increment &lt;- 5000  # Adjust based on desired chunk size

    # Placeholder for the decompressed content
    decompressed_content &lt;- character(0)

    # Loop to make multiple requests and decompress chunk by chunk
    for (i in 1:5) {  # Adjust the loop count based on the number of chunks you want to retrieve
      range_end &lt;- range_start + range_increment

      # Make a byte-range request
      response &lt;- httr::GET(url, httr::add_headers(`Range` = paste0("bytes=", range_start, "-", range_end)))

      # Check if the request was successful
      if (httr::http_type(response) != "application/octet-stream" || httr::http_status(response)$category != "Success") {
        stop("Failed to retrieve data.")
      }

      # Decompress the received chunk
      compressed_data &lt;- httr::content(response, "raw")
      decompressed_chunk &lt;- decompressor$decompress(compressed_data)
      decompressed_content &lt;- c(decompressed_content, rawToChar(decompressed_chunk))

      # Update the byte range for the next request
      range_start &lt;- range_end + 1
    }

    # Flush the decompressor after all chunks have been processed
    final_data &lt;- decompressor$flush()
    decompressed_content &lt;- c(decompressed_content, rawToChar(final_data))
  </pre>
</dd>
</dl>
<p>In summary, while Râ€™s built-in methods could someday catch up in functionality, the zlib package for now fills an important gap by providing a more robust and flexible way to handle compression and decompression tasks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">.onLoad(libname, pkgname)
</code></pre>


<h3>Details</h3>

<p>The following 'zlib' enrivonment is generated by the .onLoad Behavior for R packages.
</p>
<p>The .onLoad function is automatically called when the package is loaded using
<code>library()</code> or <code>require()</code>. It initializes the an environment,
which can be reached from anywhere and is unique (i.e. cannot be ovwerwritten),
including defining a variety of constants / methods related to the zlib compression
library.
</p>
<p>Specifically, the function assigns a new environment named "zlib" containing
constants such as <code>DEFLATED</code>, <code>DEF_BUF_SIZE</code>, <code>MAX_WBITS</code>,
and various flush and compression strategies like <code>Z_FINISH</code>,
<code>Z_BEST_COMPRESSION</code>, etc.
</p>


<h3>Value</h3>

<p>No return value, called for side effect. An environment containing the zlib constants created onLoad.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>compressobj(...)</code>: Create a compression object.
</p>
</li>
<li> <p><code>decompressobj(...)</code>: Create a decompression object.
</p>
</li>
<li> <p><code>compress(data, ...)</code>: Compress data in a single step.
</p>
</li>
<li> <p><code>decompress(data, ...)</code>: Decompress data in a single step.
</p>
</li>
</ul>
<h3>Constants</h3>


<ul>
<li> <p><code>DEFLATED</code>: The compression method, set to 8.
</p>
</li>
<li> <p><code>DEF_BUF_SIZE</code>: The default buffer size, set to 16384.
</p>
</li>
<li> <p><code>DEF_MEM_LEVEL</code>: Default memory level, set to 8.
</p>
</li>
<li> <p><code>MAX_WBITS</code>: Maximum size of the history buffer, set to 15.
</p>
</li>
<li> <p><code>Z_BEST_COMPRESSION</code>: Best compression level, set to 9.
</p>
</li>
<li> <p><code>Z_BEST_SPEED</code>: Best speed for compression, set to 1.
</p>
</li>
<li> <p><code>Z_BLOCK</code>: Block compression mode, set to 5.
</p>
</li>
<li> <p><code>Z_DEFAULT_COMPRESSION</code>: Default compression level, set to -1.
</p>
</li>
<li> <p><code>Z_DEFAULT_STRATEGY</code>: Default compression strategy, set to 0.
</p>
</li>
<li> <p><code>Z_FILTERED</code>: Filtered compression mode, set to 1.
</p>
</li>
<li> <p><code>Z_FINISH</code>: Finish compression mode, set to 4.
</p>
</li>
<li> <p><code>Z_FULL_FLUSH</code>: Full flush mode, set to 3.
</p>
</li>
<li> <p><code>Z_HUFFMAN_ONLY</code>: Huffman-only compression mode, set to 2.
</p>
</li>
<li> <p><code>Z_NO_COMPRESSION</code>: No compression, set to 0.
</p>
</li>
<li> <p><code>Z_NO_FLUSH</code>: No flush mode, set to 0.
</p>
</li>
<li> <p><code>Z_PARTIAL_FLUSH</code>: Partial flush mode, set to 1.
</p>
</li>
<li> <p><code>Z_RLE</code>: Run-length encoding compression mode, set to 3.
</p>
</li>
<li> <p><code>Z_SYNC_FLUSH</code>: Synchronized flush mode, set to 2.
</p>
</li>
<li> <p><code>Z_TREES</code>: Tree block compression mode, set to 6.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>publicEval()</code> for the method used to set up the public environment.
</p>
<p><code>zlib_constants()</code> for the method used to set up the constants in the environment. https://www.zlib.net/manual.html#Constants
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load the package
library(zlib)
# Create a temporary file
temp_file &lt;- tempfile(fileext = ".txt")

# Generate example data and write to the temp file
example_data &lt;- "This is an example string. It contains more than just 'hello, world!'"
writeBin(charToRaw(example_data), temp_file)

# Read data from the temp file into a raw vector
file_con &lt;- file(temp_file, "rb")
raw_data &lt;- readBin(file_con, "raw", file.info(temp_file)$size)
close(file_con)
# Create a Compressor object gzip
compressor &lt;- zlib$compressobj(zlib$Z_DEFAULT_COMPRESSION, zlib$DEFLATED, zlib$MAX_WBITS + 16)

# Initialize variables for chunked compression
chunk_size &lt;- 1024
compressed_data &lt;- raw(0)

# Compress the data in chunks
for (i in seq(1, length(raw_data), by = chunk_size)) {
   chunk &lt;- raw_data[i:min(i + chunk_size - 1, length(raw_data))]
   compressed_chunk &lt;- compressor$compress(chunk)
   compressed_data &lt;- c(compressed_data, compressed_chunk)
}

# Flush the compressor buffer
compressed_data &lt;- c(compressed_data, compressor$flush())


# Create a Decompressor object for gzip
decompressor &lt;- zlib$decompressobj(zlib$MAX_WBITS + 16)

# Initialize variable for decompressed data
decompressed_data &lt;- raw(0)

# Decompress the data in chunks
for (i in seq(1, length(compressed_data), by = chunk_size)) {
  chunk &lt;- compressed_data[i:min(i + chunk_size - 1, length(compressed_data))]
  decompressed_chunk &lt;- decompressor$decompress(chunk)
  decompressed_data &lt;- c(decompressed_data, decompressed_chunk)
}

# Flush the decompressor buffer
decompressed_data &lt;- c(decompressed_data, decompressor$flush())

# Comporess / Decompress data in a single step

original_data &lt;- charToRaw("some data")
compressed_data &lt;- zlib$compress(original_data,
                                 zlib$Z_DEFAULT_COMPRESSION,
                                 zlib$DEFLATED,
                                 zlib$MAX_WBITS + 16)
decompressed_data &lt;- zlib$decompress(compressed_data, zlib$MAX_WBITS + 16)

</code></pre>


</div>